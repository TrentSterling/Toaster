#pragma kernel ClearFroxels
#pragma kernel InjectMedia
#pragma kernel IntegrateFroxels

#pragma multi_compile _ TEMPORAL_REPROJECTION

#include "ToasterFroxelCommon.hlsl"

// ============================================================
// Froxel textures
// ============================================================

RWTexture3D<float4> FroxelScattering;  // (inScattered.rgb, extinction)
RWTexture3D<float4> FroxelIntegrated;  // (accLight.rgb, transmittance)

#ifdef TEMPORAL_REPROJECTION
Texture3D<float4> FroxelHistory;       // Previous frame's scattering
float _TemporalBlendAlpha;             // EMA blend weight (0.05 = 95% history)
#endif

// ============================================================
// Volume data
// ============================================================

struct VolumeGPUData
{
    float4 boundsMin;  // xyz = world min, w = unused
    float4 boundsMax;  // xyz = world max, w = unused
    float4 settings;   // x = density, y = intensity, z = gridIndex, w = edgeFalloff
};

StructuredBuffer<VolumeGPUData> _VolumeDataBuffer;
int _VolumeCount;

// Volume grids — can't use Texture3D arrays in HLSL, use named slots
Texture3D<float4> VolumeGrid0;
Texture3D<float4> VolumeGrid1;
Texture3D<float4> VolumeGrid2;
Texture3D<float4> VolumeGrid3;
Texture3D<float4> VolumeGrid4;
Texture3D<float4> VolumeGrid5;
Texture3D<float4> VolumeGrid6;
Texture3D<float4> VolumeGrid7;

// Unity inline sampler — guaranteed bilinear + clamp, no manual binding needed
SamplerState sampler_linear_clamp;

// Global fog params
float _FogDensity;
float _FogIntensity;
float _ScatteringAlbedo;
float4 _AmbientFogColor;
float _LightDensityBoost;
int _EnableHeightFog;
float _HeightFogBase;
float _HeightFogTop;

// ============================================================
// Scene lights
// ============================================================

struct LightGPUData
{
    float4 positionAndRange;    // xyz = position, w = range
    float4 colorAndIntensity;   // rgb = color, w = intensity
    float4 directionAndAngle;   // xyz = forward dir, w = cos(spotAngle * 0.5)
    float4 typeAndFlags;        // x = type (0=point, 1=spot, 2=directional), y = cos(innerAngle)
};

StructuredBuffer<LightGPUData> _LightDataBuffer;
int _LightCount;
float _ScatterAnisotropy; // Henyey-Greenstein g parameter (-1..1)

// Max shadow ray steps — higher = more accurate but slower
// 32 steps is enough for most scenes (each step = ~1 voxel width)
#define SHADOW_MAX_STEPS 32
#define SHADOW_DENSITY_THRESHOLD 0.5 // accumulated density for full occlusion

// ============================================================
// Helpers
// ============================================================

float4 SampleVolumeGrid(int gridIndex, float3 uvw)
{
    // Switch-case dispatch — HLSL can't index Texture3D arrays
    switch (gridIndex)
    {
        case 0: return VolumeGrid0.SampleLevel(sampler_linear_clamp, uvw, 0);
        case 1: return VolumeGrid1.SampleLevel(sampler_linear_clamp, uvw, 0);
        case 2: return VolumeGrid2.SampleLevel(sampler_linear_clamp, uvw, 0);
        case 3: return VolumeGrid3.SampleLevel(sampler_linear_clamp, uvw, 0);
        case 4: return VolumeGrid4.SampleLevel(sampler_linear_clamp, uvw, 0);
        case 5: return VolumeGrid5.SampleLevel(sampler_linear_clamp, uvw, 0);
        case 6: return VolumeGrid6.SampleLevel(sampler_linear_clamp, uvw, 0);
        case 7: return VolumeGrid7.SampleLevel(sampler_linear_clamp, uvw, 0);
        default: return float4(0, 0, 0, 0);
    }
}

// ============================================================
// Voxel shadow ray — march through baked grids toward light
// Returns shadow factor: 1 = fully lit, 0 = fully occluded
// ============================================================

float MarchVoxelShadow(float3 worldPos, float3 toLightDir, float maxDist)
{
    float accDensity = 0.0;

    // March through each active volume
    for (int v = 0; v < _VolumeCount; v++)
    {
        VolumeGPUData vol = _VolumeDataBuffer[v];
        int gridIdx = (int)vol.settings.z;

        float3 bMin = vol.boundsMin.xyz;
        float3 bMax = vol.boundsMax.xyz;
        float3 volSize = bMax - bMin;

        // Ray-AABB intersection — find entry/exit t along the ray
        float3 invDir = 1.0 / (toLightDir + float3(0.000001, 0.000001, 0.000001));
        float3 t0 = (bMin - worldPos) * invDir;
        float3 t1 = (bMax - worldPos) * invDir;
        float3 tMin = min(t0, t1);
        float3 tMax = max(t0, t1);

        float tEntry = max(max(tMin.x, tMin.y), tMin.z);
        float tExit  = min(min(tMax.x, tMax.y), tMax.z);

        // Start from current position (or volume entry if outside)
        tEntry = max(tEntry, 0.0);
        tExit  = min(tExit, maxDist);

        if (tEntry >= tExit) continue; // ray misses this volume

        // Step size — roughly 1 voxel width in UVW space
        float stepWorld = max(max(volSize.x, volSize.y), volSize.z) / (float)SHADOW_MAX_STEPS;
        float t = tEntry + stepWorld * 0.5; // half-step offset to avoid self-shadow

        for (int s = 0; s < SHADOW_MAX_STEPS; s++)
        {
            if (t >= tExit) break;

            float3 samplePos = worldPos + toLightDir * t;
            float3 uvw = (samplePos - bMin) / volSize;

            // Sample density from baked grid (alpha channel = voxel occupancy)
            float density = SampleVolumeGrid(gridIdx, uvw).a;
            accDensity += density * stepWorld;

            // Early out if fully occluded
            if (accDensity >= SHADOW_DENSITY_THRESHOLD)
                return 0.0;

            t += stepWorld;
        }
    }

    // Exponential falloff — soft shadow from accumulated density
    return exp(-accDensity * (1.0 / SHADOW_DENSITY_THRESHOLD) * 4.0);
}

// Henyey-Greenstein phase function — anisotropic light scattering
// g > 0 = forward scattering (looking into light), g < 0 = back scattering, g = 0 = isotropic
float HenyeyGreenstein(float cosTheta, float g)
{
    float g2 = g * g;
    float denom = 1.0 + g2 - 2.0 * g * cosTheta;
    return (1.0 - g2) / (4.0 * 3.14159265 * pow(abs(denom), 1.5));
}

// Evaluate a single scene light at a world position (with voxel occlusion)
float3 EvaluateLight(LightGPUData light, float3 worldPos, float3 viewDir)
{
    int lightType = (int)light.typeAndFlags.x;

    // Skip directional lights — their contribution is already in the baked grid
    // (the path tracer traces shadow rays from sun, so baked color includes sunlight)
    if (lightType == 2)
        return float3(0, 0, 0);

    float3 lightColor = light.colorAndIntensity.rgb * light.colorAndIntensity.w;

    float3 delta = light.positionAndRange.xyz - worldPos;
    float dist = length(delta);
    float range = light.positionAndRange.w;

    if (dist >= range) return float3(0, 0, 0);

    float3 toLight = delta / max(dist, 0.001);

    // Smooth distance attenuation (URP style)
    float distNorm = dist / range;
    float distNorm2 = distNorm * distNorm;
    float falloff = saturate(1.0 - distNorm2 * distNorm2);
    float attenuation = (falloff * falloff) / max(dist * dist, 0.0001);

    // Spot cone attenuation
    if (lightType == 1)
    {
        float cosOuter = light.directionAndAngle.w;
        float cosInner = light.typeAndFlags.y;
        float cosAngle = dot(-toLight, light.directionAndAngle.xyz);
        attenuation *= saturate((cosAngle - cosOuter) / max(cosInner - cosOuter, 0.001));
    }

    // Early out before expensive shadow march
    if (attenuation < 0.001) return float3(0, 0, 0);

    // Voxel shadow ray — march through baked geometry toward the light
    float shadow = MarchVoxelShadow(worldPos, toLight, dist);

    // Phase function — how much light scatters toward the camera
    float cosTheta = dot(toLight, viewDir);
    float phase = HenyeyGreenstein(cosTheta, _ScatterAnisotropy);

    return lightColor * attenuation * phase * shadow;
}

// Evaluate all scene lights at a world position
float3 EvaluateSceneLights(float3 worldPos, float3 viewDir)
{
    float3 totalLight = float3(0, 0, 0);
    for (int i = 0; i < _LightCount; i++)
    {
        totalLight += EvaluateLight(_LightDataBuffer[i], worldPos, viewDir);
    }
    return totalLight;
}

// Edge falloff — fade density near volume boundaries for smooth overlap
float EdgeFalloff(float3 uvw, float falloff)
{
    if (falloff <= 0.0) return 1.0;
    float3 edgeDist = min(uvw, 1.0 - uvw);
    float minDist = min(edgeDist.x, min(edgeDist.y, edgeDist.z));
    return saturate(minDist / falloff);
}

// ============================================================
// Kernel 0: Clear froxel scattering grid
// ============================================================

[numthreads(4, 4, 4)]
void ClearFroxels(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= (uint3)FroxelResolution))
        return;
    FroxelScattering[id] = float4(0, 0, 0, 0);
}

// ============================================================
// Kernel 1: Inject media — sample all volumes into froxel grid
// ============================================================

[numthreads(4, 4, 4)]
void InjectMedia(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= (uint3)FroxelResolution))
        return;

    // Jitter Z to reduce banding
    float jitter = GetBlueNoiseJitter(id.xy, _FrameIndex) - 0.5;

    // Reconstruct world position for this froxel
    float3 worldPos = FroxelToWorld(id, jitter);

    // View direction from camera to froxel (for phase function)
    float3 viewDir = normalize(worldPos - _CameraPos);

    // Evaluate scene lights ONCE per froxel (not per-volume — avoids double-counting in overlap)
    float3 directLight = EvaluateSceneLights(worldPos, viewDir);

    // Compute light-localized density boost ONCE per froxel
    float lightBoost = 0.0;
    if (_LightDensityBoost > 0.0)
    {
        for (int i = 0; i < _LightCount; i++)
        {
            LightGPUData light = _LightDataBuffer[i];
            int lightType = (int)light.typeAndFlags.x;

            if (lightType == 2) // Directional — no localized density
                continue;

            float3 delta = light.positionAndRange.xyz - worldPos;
            float dist = length(delta);
            float range = light.positionAndRange.w;
            if (dist >= range) continue;

            float distNorm = dist / range;
            float distNorm2 = distNorm * distNorm;
            float atten = saturate(1.0 - distNorm2 * distNorm2);
            atten *= atten;

            // Spot cone mask
            if (lightType == 1)
            {
                float cosOuter = light.directionAndAngle.w;
                float cosInner = light.typeAndFlags.y;
                float3 toLight = delta / max(dist, 0.001);
                float cosAngle = dot(-toLight, light.directionAndAngle.xyz);
                atten *= saturate((cosAngle - cosOuter) / max(cosInner - cosOuter, 0.001));
            }

            lightBoost += atten * light.colorAndIntensity.w; // weight by intensity
        }
    }

    // Accumulate scattering and extinction from all volumes
    float3 scattering = float3(0, 0, 0);
    float extinction = 0.0;

    for (int v = 0; v < _VolumeCount; v++)
    {
        VolumeGPUData vol = _VolumeDataBuffer[v];

        float3 bMin = vol.boundsMin.xyz;
        float3 bMax = vol.boundsMax.xyz;

        // Check if froxel is inside this volume
        if (any(worldPos < bMin) || any(worldPos > bMax))
            continue;

        // World pos → volume UVW [0,1]
        float3 uvw = (worldPos - bMin) / (bMax - bMin);

        // Edge falloff
        float edgeFade = EdgeFalloff(uvw, vol.settings.w);

        // Uniform fog density — exists everywhere in the volume (like real atmosphere)
        float baseDensity = vol.settings.x * _FogDensity * edgeFade;

        // Height fog — density ramps down with altitude
        if (_EnableHeightFog)
        {
            float t = saturate((worldPos.y - _HeightFogBase) / max(_HeightFogTop - _HeightFogBase, 0.01));
            baseDensity *= 1.0 - sqrt(t); // sqrt falloff — denser at bottom
        }

        // Sample baked lighting for the in-scattered light color
        int gridIdx = (int)vol.settings.z;
        float4 voxelData = SampleVolumeGrid(gridIdx, uvw);

        // Fog color = (baked light + ambient) scaled by intensity
        float3 bakedColor = (voxelData.rgb + _AmbientFogColor.rgb)
                          * vol.settings.y * _FogIntensity;

        // In-scattering = color * density * albedo
        // Albedo decouples brightness from opacity — >1 makes thin fog visible
        scattering += (bakedColor + directLight) * baseDensity * _ScatteringAlbedo;
        extinction += baseDensity;
    }

    // Light-localized density boost: applied once on top of total volume density
    if (lightBoost > 0.0 && extinction > 0.0)
    {
        float boostExtinction = lightBoost * _LightDensityBoost * _FogDensity;
        extinction += boostExtinction;
        scattering += directLight * boostExtinction * _ScatteringAlbedo;
    }

    float4 result = float4(scattering, extinction);

    // Temporal reprojection — blend with previous frame
    #ifdef TEMPORAL_REPROJECTION
    {
        // Reproject current world pos to previous frame's froxel UV
        float4 prevClip = mul(_PrevViewProj, float4(worldPos, 1.0));
        prevClip.xyz /= prevClip.w;
        float2 prevUV = prevClip.xy * 0.5 + 0.5;
        #if UNITY_UV_STARTS_AT_TOP
        prevUV.y = 1.0 - prevUV.y;
        #endif

        // Check if reprojected position is within screen
        if (all(prevUV >= 0.0) && all(prevUV <= 1.0))
        {
            float prevDepth = SliceToDepth((float)id.z + 0.5);
            float prevSlice = DepthToSlice(prevDepth); // Approximate — assumes similar depth distribution
            float3 historyUVW = float3(prevUV, prevSlice / (float)_FroxelResZ);

            float4 history = FroxelHistory.SampleLevel(sampler_linear_clamp, historyUVW, 0);

            // Exponential moving average
            result = lerp(history, result, _TemporalBlendAlpha);
        }
    }
    #endif

    FroxelScattering[id] = result;
}

// ============================================================
// Kernel 2: Integrate froxels — front-to-back Beer-Lambert
// Per (x,y) column, walk all Z slices
// ============================================================

[numthreads(8, 8, 1)]
void IntegrateFroxels(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_FroxelResX || id.y >= (uint)_FroxelResY)
        return;

    float3 accLight = float3(0, 0, 0);
    float transmittance = 1.0;

    for (int z = 0; z < _FroxelResZ; z++)
    {
        float4 scatterData = FroxelScattering[int3(id.xy, z)];
        float3 inScattered = scatterData.rgb;
        float ext = scatterData.a;

        // Distance between this slice and next (in world units)
        float d0 = SliceToDepth((float)z);
        float d1 = SliceToDepth((float)(z + 1));
        float travelDist = d1 - d0;

        // Beer-Lambert extinction for this slice
        float sliceTransmittance = exp(-ext * travelDist);

        // Energy-conserving in-scattering integral within the slice:
        // Exact: integral of S * exp(-sigma*x) dx from 0 to d = S * (1 - exp(-sigma*d)) / sigma
        // For near-zero extinction, fall back to thin-slab approximation (S * d)
        float3 sliceScattering;
        if (ext > 0.00001)
            sliceScattering = inScattered * ((1.0 - sliceTransmittance) / ext) * transmittance;
        else
            sliceScattering = inScattered * travelDist * transmittance;
        accLight += sliceScattering;

        transmittance *= sliceTransmittance;

        // Write integrated result at each depth (needed for apply shader lookup)
        FroxelIntegrated[int3(id.xy, z)] = float4(accLight, transmittance);
    }
}
