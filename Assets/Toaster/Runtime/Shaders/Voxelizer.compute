#pragma kernel VoxelizeMesh
#pragma kernel ClearGrid
#pragma kernel ClearAccum
#pragma kernel FinalizeGrid

// --- Inputs ---
StructuredBuffer<float3> Vertices;
StructuredBuffer<float3> Normals;
StructuredBuffer<float2> UVs;
StructuredBuffer<int> Indices;

// The "Meta" texture we just baked for this submesh
Texture2D<float4> MetaTexture;
SamplerState samplerMetaTexture;

// The global voxel grid we are writing to
RWTexture3D<float4> VoxelGrid;

// Atomic accumulation buffer: 4 uints per voxel [R_fixed, G_fixed, B_fixed, Count]
RWStructuredBuffer<uint> AccumBuffer;

// Setup
float4x4 LocalToWorld;
float3 WorldBoundsMin;
float VoxelSize;
int GridResX;
int GridResY;
int GridResZ;
#define GridResolution int3(GridResX, GridResY, GridResZ)
int IndexOffset;
int TriangleCount;

// Fixed-point scale (10 bits fractional precision)
static const uint FP_SCALE = 1024;

// --- Math Helpers ---

int FlatIndex(int3 coord)
{
    return (coord.z * GridResolution.y * GridResolution.x + coord.y * GridResolution.x + coord.x) * 4;
}

// Full SAT (Separating Axis Theorem) triangle-box intersection test
// Based on Akenine-Möller (2001) — tests 13 separating axes:
//   3 box face normals, 1 triangle normal, 9 edge cross products
bool AABBIntersectsTriangle(float3 boxMin, float3 boxMax, float3 v0, float3 v1, float3 v2)
{
    // 1. AABB overlap (box face normals — 3 axes)
    float3 triMin = min(v0, min(v1, v2));
    float3 triMax = max(v0, max(v1, v2));
    if (any(triMin > boxMax) || any(triMax < boxMin))
        return false;

    // Center the box at origin for cleaner math
    float3 center = (boxMin + boxMax) * 0.5;
    float3 halfSize = (boxMax - boxMin) * 0.5;
    float3 t0 = v0 - center;
    float3 t1 = v1 - center;
    float3 t2 = v2 - center;

    // Triangle edges
    float3 e0 = t1 - t0;
    float3 e1 = t2 - t1;
    float3 e2 = t0 - t2;

    // 2. Triangle normal axis
    float3 triNormal = cross(e0, e1);
    float d = dot(triNormal, t0);
    float r = dot(halfSize, abs(triNormal));
    if (abs(d) > r)
        return false;

    // 3. Cross product axes (9 axes: 3 box axes × 3 triangle edges)
    // For each axis a = boxAxis × triangleEdge, project triangle and box onto a
    // and check for overlap.

    // Helper: test one cross-product axis
    // a = unit axis × edge, project triangle verts and box extents
    #define SAT_CROSS_TEST(ax, ay, az, p0, p1, p2, rad) \
    { \
        float _p0 = (p0); float _p1 = (p1); float _p2 = (p2); \
        float _min = min(_p0, min(_p1, _p2)); \
        float _max = max(_p0, max(_p1, _p2)); \
        float _rad = (rad); \
        if (_min > _rad || _max < -_rad) return false; \
    }

    float fex, fey, fez;

    // e0 cross products
    fex = abs(e0.x); fey = abs(e0.y); fez = abs(e0.z);
    SAT_CROSS_TEST(0, -e0.z, e0.y,
        t0.y * e0.z - t0.z * e0.y,
        t1.y * e0.z - t1.z * e0.y,
        t2.y * e0.z - t2.z * e0.y,
        halfSize.y * fez + halfSize.z * fey)
    SAT_CROSS_TEST(e0.z, 0, -e0.x,
        t0.z * e0.x - t0.x * e0.z,
        t1.z * e0.x - t1.x * e0.z,
        t2.z * e0.x - t2.x * e0.z,
        halfSize.x * fez + halfSize.z * fex)
    SAT_CROSS_TEST(-e0.y, e0.x, 0,
        t0.x * e0.y - t0.y * e0.x,
        t1.x * e0.y - t1.y * e0.x,
        t2.x * e0.y - t2.y * e0.x,
        halfSize.x * fey + halfSize.y * fex)

    // e1 cross products
    fex = abs(e1.x); fey = abs(e1.y); fez = abs(e1.z);
    SAT_CROSS_TEST(0, -e1.z, e1.y,
        t0.y * e1.z - t0.z * e1.y,
        t1.y * e1.z - t1.z * e1.y,
        t2.y * e1.z - t2.z * e1.y,
        halfSize.y * fez + halfSize.z * fey)
    SAT_CROSS_TEST(e1.z, 0, -e1.x,
        t0.z * e1.x - t0.x * e1.z,
        t1.z * e1.x - t1.x * e1.z,
        t2.z * e1.x - t2.x * e1.z,
        halfSize.x * fez + halfSize.z * fex)
    SAT_CROSS_TEST(-e1.y, e1.x, 0,
        t0.x * e1.y - t0.y * e1.x,
        t1.x * e1.y - t1.y * e1.x,
        t2.x * e1.y - t2.y * e1.x,
        halfSize.x * fey + halfSize.y * fex)

    // e2 cross products
    fex = abs(e2.x); fey = abs(e2.y); fez = abs(e2.z);
    SAT_CROSS_TEST(0, -e2.z, e2.y,
        t0.y * e2.z - t0.z * e2.y,
        t1.y * e2.z - t1.z * e2.y,
        t2.y * e2.z - t2.z * e2.y,
        halfSize.y * fez + halfSize.z * fey)
    SAT_CROSS_TEST(e2.z, 0, -e2.x,
        t0.z * e2.x - t0.x * e2.z,
        t1.z * e2.x - t1.x * e2.z,
        t2.z * e2.x - t2.x * e2.z,
        halfSize.x * fez + halfSize.z * fex)
    SAT_CROSS_TEST(-e2.y, e2.x, 0,
        t0.x * e2.y - t0.y * e2.x,
        t1.x * e2.y - t1.y * e2.x,
        t2.x * e2.y - t2.y * e2.x,
        halfSize.x * fey + halfSize.y * fex)

    #undef SAT_CROSS_TEST

    return true;
}

// Barycentric coordinates to interpolate UVs
float3 CalculateBarycentric(float3 p, float3 a, float3 b, float3 c)
{
    float3 v0 = b - a, v1 = c - a, v2 = p - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;

    if (abs(denom) < 1e-5)
        return float3(1, 0, 0); // Degenerate triangle

    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0f - v - w;
    return float3(u, v, w);
}

[numthreads(64, 1, 1)]
void VoxelizeMesh(uint3 id : SV_DispatchThreadID)
{
    if ((int) id.x >= TriangleCount)
        return;

    // 1. Get Triangle Data
    int idx = IndexOffset + (id.x * 3);
    int i0 = Indices[idx];
    int i1 = Indices[idx + 1];
    int i2 = Indices[idx + 2];

    float3 v0 = mul(LocalToWorld, float4(Vertices[i0], 1)).xyz;
    float3 v1 = mul(LocalToWorld, float4(Vertices[i1], 1)).xyz;
    float3 v2 = mul(LocalToWorld, float4(Vertices[i2], 1)).xyz;

    float2 uv0 = UVs[i0];
    float2 uv1 = UVs[i1];
    float2 uv2 = UVs[i2];

    // 2. Calculate Triangle Bounds in Voxel Grid Space
    float3 triMin = min(v0, min(v1, v2));
    float3 triMax = max(v0, max(v1, v2));

    int3 gridMin = max(0, (int3) ((triMin - WorldBoundsMin) / VoxelSize));
    int3 gridMax = min(GridResolution - 1, (int3) ((triMax - WorldBoundsMin) / VoxelSize));

    // 3. Iterate over potential Voxels
    for (int z = gridMin.z; z <= gridMax.z; z++)
    {
        for (int y = gridMin.y; y <= gridMax.y; y++)
        {
            for (int x = gridMin.x; x <= gridMax.x; x++)
            {
                float3 voxelCenter = WorldBoundsMin + (float3(x, y, z) * VoxelSize) + (VoxelSize * 0.5);
                float3 voxelMin = voxelCenter - (VoxelSize * 0.5);
                float3 voxelMax = voxelCenter + (VoxelSize * 0.5);

                if (AABBIntersectsTriangle(voxelMin, voxelMax, v0, v1, v2))
                {
                    // 4. Hit! Get Color from Meta Texture
                    float3 bary = CalculateBarycentric(voxelCenter, v0, v1, v2);
                    float2 interpolatedUV = uv0 * bary.x + uv1 * bary.y + uv2 * bary.z;
                    float4 albedo = MetaTexture.SampleLevel(samplerMetaTexture, interpolatedUV, 0);

                    // 5. Atomic accumulate — fixed-point InterlockedAdd avoids race conditions
                    int base_idx = FlatIndex(int3(x, y, z));
                    uint r_fixed = (uint)(saturate(albedo.r) * FP_SCALE);
                    uint g_fixed = (uint)(saturate(albedo.g) * FP_SCALE);
                    uint b_fixed = (uint)(saturate(albedo.b) * FP_SCALE);

                    uint dummy;
                    InterlockedAdd(AccumBuffer[base_idx + 0], r_fixed, dummy);
                    InterlockedAdd(AccumBuffer[base_idx + 1], g_fixed, dummy);
                    InterlockedAdd(AccumBuffer[base_idx + 2], b_fixed, dummy);
                    InterlockedAdd(AccumBuffer[base_idx + 3], 1, dummy);
                }
            }
        }
    }
}

// Finalize: average accumulated colors and write to the 3D texture
[numthreads(8, 8, 8)]
void FinalizeGrid(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= (uint3) GridResolution))
        return;

    int base_idx = FlatIndex(id);
    uint count = AccumBuffer[base_idx + 3];
    if (count == 0)
        return;

    float r = (float) AccumBuffer[base_idx + 0] / (FP_SCALE * count);
    float g = (float) AccumBuffer[base_idx + 1] / (FP_SCALE * count);
    float b = (float) AccumBuffer[base_idx + 2] / (FP_SCALE * count);

    VoxelGrid[id] = float4(r, g, b, 1.0);
}

// Zero the accumulation buffer
[numthreads(64, 1, 1)]
void ClearAccum(uint3 id : SV_DispatchThreadID)
{
    uint totalEntries = (uint)(GridResolution.x * GridResolution.y * GridResolution.z) * 4;
    if (id.x >= totalEntries)
        return;
    AccumBuffer[id.x] = 0;
}

[numthreads(8, 8, 8)]
void ClearGrid(uint3 id : SV_DispatchThreadID)
{
    if (any(id >= (uint3) GridResolution))
        return;
    VoxelGrid[id] = float4(0, 0, 0, 0);
}
